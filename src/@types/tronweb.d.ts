/** Declaration file generated by dts-gen */


declare module 'tronweb' {

	class address {
		fromHex(t: any): any;

		fromPrivateKey(privateKey: string): string; // returns base58

		toHex(t: any): any;

	}

	export default class tronweb {
		constructor(...args: any[]);

		contract(...args: any[]): any;

		currentProvider(): any;

		currentProviders(): any;

		fullnodeSatisfies(t: any): any;

		getEventByTransactionID(...args: any[]): any;

		getEventResult(...args: any[]): any;

		getFullnodeVersion(...args: any[]): any;

		isConnected(...args: any[]): any;

		isValidProvider(t: any): any;

		setAddress(t: any): void;

		setDefaultBlock(...args: any[]): any;

		setEventHeader(...args: any[]): void;

		setEventServer(...args: any[]): void;

		setFullNode(t: any): void;

		setFullNodeHeader(...args: any[]): void;

		setHeader(...args: any[]): void;

		setPrivateKey(t: any): void;

		setSolidityNode(t: any): void;

		createAccount(...args: any[]): Promise<{
			privateKey: string
			publicKey: string,
			address: {
				base58: string // starts T. Use this format.
				hex: string
			}
		}>;

		static createRandom(t: any): any;

		static fromAscii(t: any, e: any): any;

		static fromDecimal(t: any): any;

		static fromMnemonic(t: any, ...args: any[]): any;

		static fromSun(t: any): any;

		static fromUtf8(t: any): any;

		static isAddress(...args: any[]): any;

		static prefixed: boolean;

		static sha3(t: any, ...args: any[]): any;

		static toAscii(t: any): any;

		static toBigNumber(...args: any[]): any;

		static toDecimal(t: any): any;

		static toHex(t: any): any;

		static toSun(t: any): any;

		static toUtf8(t: any): any;

		static version: string;

		trx: Trx
		transactionBuilder: TransactionBuilder
		contract: Contract
		// utils: utils
		address: address

	}


	class BigNumber {
		constructor(v: any, b: any);

		abs(): any;

		absoluteValue(): any;

		comparedTo(y: any, b: any): any;

		decimalPlaces(dp: any, rm: any): any;

		div(y: any, b: any): any;

		dividedBy(y: any, b: any): any;

		dividedToIntegerBy(y: any, b: any): any;

		dp(dp: any, rm: any): any;

		eq(y: any, b: any): any;

		exponentiatedBy(n: any, m: any): any;

		gt(y: any, b: any): any;

		gte(y: any, b: any): any;

		idiv(y: any, b: any): any;

		integerValue(rm: any): any;

		isEqualTo(y: any, b: any): any;

		isFinite(): any;

		isGreaterThan(y: any, b: any): any;

		isGreaterThanOrEqualTo(y: any, b: any): any;

		isInteger(): any;

		isLessThan(y: any, b: any): any;

		isLessThanOrEqualTo(y: any, b: any): any;

		isNaN(): any;

		isNegative(): any;

		isPositive(): any;

		isZero(): any;

		lt(y: any, b: any): any;

		lte(y: any, b: any): any;

		minus(y: any, b: any): any;

		mod(y: any, b: any): any;

		modulo(y: any, b: any): any;

		multipliedBy(y: any, b: any): any;

		negated(): any;

		plus(y: any, b: any): any;

		pow(n: any, m: any): any;

		precision(sd: any, rm: any): any;

		sd(sd: any, rm: any): any;

		shiftedBy(k: any): any;

		sqrt(): any;

		squareRoot(): any;

		times(y: any, b: any): any;

		toExponential(dp: any, rm: any): any;

		toFixed(dp: any, rm: any): any;

		toFormat(dp: any, rm: any, format: any): any;

		toFraction(md: any): any;

		toJSON(): any;

		toNumber(): any;

		toPrecision(sd: any, rm: any): any;

		toString(b: any): any;

		valueOf(): any;

		static BigNumber: any;

		static EUCLID: number;

		static ROUND_CEIL: number;

		static ROUND_DOWN: number;

		static ROUND_FLOOR: number;

		static ROUND_HALF_CEIL: number;

		static ROUND_HALF_DOWN: number;

		static ROUND_HALF_EVEN: number;

		static ROUND_HALF_FLOOR: number;

		static ROUND_HALF_UP: number;

		static ROUND_UP: number;

		static clone(configObject: any, ...args: any[]): any;

		static config(obj: any): any;

		static default: any;

		static isBigNumber(v: any): any;

		static max(...args: any[]): any;

		static maximum(...args: any[]): any;

		static min(...args: any[]): any;

		static minimum(...args: any[]): any;

		static random(dp: any): any;

		static set(obj: any): any;

		static sum(...args: any[]): any;

	}

	class Contract {
		constructor(...args: any[]);

		at(t: any, ...args: any[]): any;

		decodeInput(t: any): any;

		events(...args: any[]): any;

		hasProperty(t: any): any;

		loadAbi(t: any): any;

		new(t: any, ...args: any[]): any;

	}

	class Event {
		constructor(...args: any[]);

		getEventsByContractAddress(...args: any[]): any;

		getEventsByTransactionID(...args: any[]): any;

		setServer(...args: any[]): any;

	}

	class EventEmitter {
		constructor();

		addListener(event: any, fn: any, context: any): any;

		emit(event: any, a1: any, a2: any, a3: any, a4: any, a5: any, ...args: any[]): any;

		eventNames(): any;

		listenerCount(event: any): any;

		listeners(event: any): any;

		off(event: any, fn: any, context: any, once: any): any;

		on(event: any, fn: any, context: any): any;

		once(event: any, fn: any, context: any): any;

		removeAllListeners(event: any): any;

		removeListener(event: any, fn: any, context: any, once: any): any;

		static EventEmitter: any;

		static prefixed: boolean;

	}

	class Plugin {
		constructor(...args: any[]);

		register(t: any, e: any): any;

	}

	class TransactionBuilder {
		constructor(...args: any[]);

		addUpdateData(t: any, r: any, ...args: any[]): any;

		alterTransaction(t: any, ...args: any[]): any;

		applyForSR(...args: any[]): any;

		checkPermissions(t: any, e: any): any;

		clearABI(t: any, ...args: any[]): any;

		createAccount(t: any, ...args: any[]): any;

		createAsset(...args: any[]): any;

		createProposal(...args: any[]): any;

		createSmartContract(...args: any[]): any;

		createTRXExchange(t: any, e: any, r: any, ...args: any[]): any;

		createToken(...args: any[]): any;

		createTokenExchange(t: any, e: any, r: any, o: any, ...args: any[]): any;

		deleteProposal(...args: any[]): any;

		extendExpiration(t: any, e: any, ...args: any[]): any;

		freezeBalance(...args: any[]): any;

		injectExchangeTokens(...args: any[]): any;

		newTxID(t: any, e: any, ...args: any[]): any;

		purchaseAsset(...args: any[]): any;

		purchaseToken(...args: any[]): any;

		sendAsset(...args: any[]): any;

		sendToken(...args: any[]): any;

		sendTrx(to: string, amount: number, from: string): Promise<any>;

		setAccountId(t: any, ...args: any[]): any;

		tradeExchangeTokens(...args: any[]): any;

		triggerConfirmedConstantContract(...args: any[]): any;

		triggerConstantContract(...args: any[]): any;

		triggerSmartContract(...args: any[]): any;

		unfreezeBalance(...args: any[]): any;

		updateAccount(...args: any[]): any;

		updateAccountPermissions(...args: any[]): any;

		updateAsset(...args: any[]): any;

		updateBrokerage(t: any, ...args: any[]): any;

		updateEnergyLimit(...args: any[]): any;

		updateSetting(...args: any[]): any;

		updateToken(...args: any[]): any;

		vote(...args: any[]): any;

		voteProposal(...args: any[]): any;

		withdrawBlockRewards(...args: any[]): any;

		withdrawExchangeTokens(...args: any[]): any;

	}

	class Trx {
		constructor(...args: any[]);

		broadcast(...args: any[]): any;

		broadcastHex(...args: any[]): any;

		freezeBalance(...args: any[]): any;

		getAccount(...args: any[]): any;

		getAccountById(...args: any[]): any;

		getAccountInfoById(t: any, e: any, r: any): any;

		getAccountResources(address: string): Promise<any>;

		getApprovedList(t: any, ...args: any[]): any;

		getBalance(address: string): Promise<string>;

		getBandwidth(address: string): Promise<string>;

		getBlock(...args: any[]): any;

		getBlockByHash(t: any, ...args: any[]): any;

		getBlockByNumber(t: any, ...args: any[]): any;

		getBlockRange(...args: any[]): any;

		getBlockTransactionCount(...args: any[]): any;

		getBrokerage(t: any, ...args: any[]): any;

		getChainParameters(...args: any[]): any;

		getConfirmedCurrentBlock(...args: any[]): any;

		getConfirmedTransaction(t: any, ...args: any[]): any;

		getContract(t: any, ...args: any[]): any;

		getCurrentBlock(...args: any[]): any;

		getExchangeByID(...args: any[]): any;

		getNodeInfo(...args: any[]): any;

		getProposal(...args: any[]): any;

		getReward(t: any, ...args: any[]): any;

		getSignWeight(t: any, e: any, ...args: any[]): any;

		getTokenByID(...args: any[]): any;

		getTokenFromID(...args: any[]): any;

		getTokenListByName(...args: any[]): any;

		getTokensIssuedByAddress(...args: any[]): any;

		// ret(return) - contract result
		// https://github.com/tronprotocol/documentation/blob/master/English_Documentation/TRON_Virtual_Machine/TRC10_TRX_TRANSFER_INTRODUCTION_FOR_EXCHANGES.md
		getTransaction(txid: string): Promise<{
			ret: [{contractRet: "DEFAULT" | "SUCCESS" | "OUT_OF_ENERGY" | "REVERT" | "UNKNOWN"}]
		}>;

		getTransactionFromBlock(...args: any[]): any;

		getTransactionInfo(t: any, ...args: any[]): any;

		getTransactionsFromAddress(...args: any[]): any;

		getTransactionsRelated(...args: any[]): any;

		getTransactionsToAddress(...args: any[]): any;

		getUnconfirmedAccount(...args: any[]): any;

		getUnconfirmedAccountById(t: any, ...args: any[]): any;

		getUnconfirmedBalance(...args: any[]): any;

		getUnconfirmedBrokerage(t: any, ...args: any[]): any;

		getUnconfirmedReward(t: any, ...args: any[]): any;

		getUnconfirmedTransactionInfo(t: any, ...args: any[]): any;

		listExchanges(...args: any[]): any;

		listExchangesPaginated(...args: any[]): any;

		listNodes(...args: any[]): any;

		listProposals(...args: any[]): any;

		listSuperRepresentatives(...args: any[]): any;

		listTokens(...args: any[]): any;

		multiSign(...args: any[]): any;

		send(...args: any[]): any;

		sendAsset(...args: any[]): any;

		sendHexTransaction(...args: any[]): any;

		sendRawTransaction(signedTx: string): Promise<{result: boolean, txid: string}>;

		sendToken(...args: any[]): any;

		sendTransaction(...args: any[]): any;

		sendTrx(...args: any[]): any;

		sign(obj: any, privateKey: string): Promise<string>;

		signMessage(...args: any[]): any;

		signMessageV2(e: any, ...args: any[]): any;

		signTransaction(...args: any[]): any;

		timeUntilNextVoteCycle(...args: any[]): any;

		unfreezeBalance(...args: any[]): any;

		updateAccount(...args: any[]): any;

		verifyMessage(...args: any[]): any;

		verifyMessageV2(...args: any[]): any;

		verifyTypedData(e: any, r: any, o: any, n: any, ...args: any[]): any;

		static signMessageV2(t: any, e: any): any;

		static signString(t: any, e: any, ...args: any[]): any;

		static verifyMessageV2(t: any, e: any): any;

		static verifySignature(t: any, e: any, r: any, ...args: any[]): any;

		static verifyTypedData(t: any, e: any, r: any, o: any, n: any): any;

	}


	namespace providers {
		class HttpProvider {
			constructor(e: any, ...args: any[]);

			isConnected(...args: any[]): any;

			request(t: any, ...args: any[]): any;

			setStatusPage(...args: any[]): void;

		}

	}

	namespace utils {
		function hasProperties(t: any, ...args: any[]): any;

		function hasProperty(t: any, e: any): any;

		function isArray(t: any): any;

		function isBigNumber(t: any): any;

		function isBoolean(t: any): any;

		function isFunction(t: any): any;

		function isHex(t: any): any;

		function isInteger(t: any): any;

		function isJson(t: any): any;

		function isNotNullOrUndefined(t: any): any;

		function isObject(t: any): any;

		function isString(t: any): any;

		function isValidURL(t: any): any;

		function mapEvent(t: any): any;

		function padLeft(t: any, e: any, r: any): any;

		function parseEvent(t: any, e: any): any;

		function sleep(...args: any[]): any;

		namespace abi {
			function decodeParams(t: any, e: any, r: any, o: any): any;

			function decodeParamsV2ByABI(t: any, e: any, ...args: any[]): any;

			function encodeParams(t: any, e: any): any;

			function encodeParamsV2ByABI(t: any, e: any, ...args: any[]): any;

		}

		namespace accounts {
			function generateAccount(): any;

			function generateAccountWithMnemonic(t: any, e: any, ...args: any[]): any;

			function generateRandom(t: any): any;

		}

		namespace base58 {
			function decode58(t: any): any;

			function encode58(t: any): any;

		}

		namespace bytes {
			function base64DecodeFromString(t: any): any;

			function base64EncodeToString(t: any): any;

			function byte2hexStr(t: any): any;

			function byteArray2hexStr(t: any): any;

			function bytesToString(t: any): any;

			function hextoString(t: any): any;

		}

		namespace code {
			function arrayEquals(t: any, e: any, r: any): any;

			function base64DecodeFromString(t: any): any;

			function base64EncodeToString(t: any): any;

			function bin2String(t: any): any;

			function byte2hexStr(t: any): any;

			function byteArray2hexStr(t: any): any;

			function bytesToString(t: any): any;

			function getStringType(t: any): any;

			function hexChar2byte(t: any): any;

			function hexStr2byteArray(t: any, ...args: any[]): any;

			function hextoString(t: any): any;

			function isHexChar(t: any): any;

			function isNumber(t: any): any;

			function strToDate(t: any): any;

			function stringToBytes(t: any): any;

		}

		namespace crypto {
			function ECKeySign(t: any, e: any): any;

			function SHA256(t: any): any;

			function arrayToBase64String(t: any): any;

			function computeAddress(t: any): any;

			function decode58Check(t: any): any;

			function decodeBase58Address(t: any): any;

			function genPriKey(): any;

			function getAddressFromPriKey(t: any): any;

			function getAddressFromPriKeyBase64String(t: any): any;

			function getBase58CheckAddress(t: any): any;

			function getBase58CheckAddressFromPriKeyBase64String(t: any): any;

			function getHexStrAddressFromPriKeyBase64String(t: any): any;

			function getPubKeyFromPriKey(t: any): any;

			function getRowBytesFromTransactionBase64(t: any): any;

			function isAddressValid(t: any): any;

			function passwordToAddress(t: any): any;

			function pkToAddress(t: any, ...args: any[]): any;

			function signBytes(t: any, e: any): any;

			function signTransaction(t: any, e: any): any;

		}

		namespace ethersUtils {
			class AbiCoder {
				constructor(coerceFunc: any);

				decode(types: any, data: any, loose: any): any;

				encode(types: any, values: any): any;

				getDefaultValue(types: any): any;

			}

			class Interface {
				constructor(fragments: any);

				decodeErrorResult(fragment: any, data: any): any;

				decodeEventLog(eventFragment: any, data: any, topics: any): any;

				decodeFunctionData(functionFragment: any, data: any): any;

				decodeFunctionResult(functionFragment: any, data: any): any;

				encodeDeploy(values: any): any;

				encodeErrorResult(fragment: any, values: any): any;

				encodeEventLog(eventFragment: any, values: any): any;

				encodeFilterTopics(eventFragment: any, values: any): any;

				encodeFunctionData(functionFragment: any, values: any): any;

				encodeFunctionResult(functionFragment: any, values: any): any;

				format(format: any): any;

				getError(nameOrSignatureOrSighash: any): any;

				getEvent(nameOrSignatureOrTopic: any): any;

				getEventTopic(eventFragment: any): any;

				getFunction(nameOrSignatureOrSighash: any): any;

				getSighash(fragment: any): any;

				parseError(data: any): any;

				parseLog(log: any): any;

				parseTransaction(tx: any): any;

				static getAbiCoder(): any;

				static getAddress(address: any): any;

				static getEventTopic(eventFragment: any): any;

				static getSighash(fragment: any): any;

				static isInterface(value: any): any;

			}

			class SigningKey {
				constructor(privateKey: any);

				computeSharedSecret(otherKey: any): any;

				signDigest(digest: any): any;

				static isSigningKey(value: any): any;

			}

			class ethersWallet {
				constructor(privateKey: any, provider: any);

				connect(provider: any): any;

				encrypt(password: any, options: any, progressCallback: any): any;

				getAddress(): any;

				signMessage(message: any): any;

				signTransaction(transaction: any): any;

				static createRandom(options: any): any;

				static fromEncryptedJson(json: any, password: any, progressCallback: any): any;

				static fromEncryptedJsonSync(json: any, password: any): any;

				static fromMnemonic(mnemonic: any, path: any, wordlist: any): any;

				static isSigner(value: any): any;

			}

			const FormatTypes: {
				full: string;
				json: string;
				minimal: string;
				sighash: string;
			};

			function arrayify(value: any, options: any): any;

			function concat(items: any): any;

			function id(text: any): any;

			function isValidMnemonic(mnemonic: any, wordlist: any): any;

			function joinSignature(signature: any): any;

			function keccak256(data: any): any;

			function recoverAddress(digest: any, signature: any): any;

			function sha256(data: any): any;

			function splitSignature(signature: any): any;

			function toUtf8Bytes(str: any, form: any): any;

			function toUtf8String(bytes: any, onError: any): any;

		}

		namespace message {
			const TRON_MESSAGE_PREFIX: string;

			function hashMessage(t: any): any;

			function signMessage(t: any, e: any): any;

			function verifyMessage(t: any, e: any): any;

		}

		namespace transaction {
			function txCheck(t: any): any;

			function txCheckWithArgs(t: any, e: any, r: any): any;

			function txJsonToPb(t: any): any;

			function txJsonToPbWithArgs(t: any, ...args: any[]): any;

			function txPbToTxID(t: any): any;

		}

	}

}

